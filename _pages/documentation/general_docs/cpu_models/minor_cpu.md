---
layout: documentation
title: Inside the Minor CPU Model
permalink: /documentation/general_docs/cpu_models/minor_cpu
author: Andrew Bardsley
---

This document contains a description of the structure and function of the
[Minor](https://gem5.github.io/gem5-doxygen/namespaceMinor.html) gem5 in-order
processor model.

It is recommended reading for anyone who wants to understand
[Minor](https://gem5.github.io/gem5-doxygen/namespaceMinor.html)'s internal
organisation, design decisions, C++ implementation and Python configuration. A
familiarity with gem5 and some of its internal structures is assumed. This
document is meant to be read alongside the
[Minor](https://gem5.github.io/gem5-doxygen/namespaceMinor.html) source code
and to explain its general structure without being too slavish about naming
every function and data type.

## What is Minor?

[Minor](https://gem5.github.io/gem5-doxygen/namespaceMinor.html) is an in-order
processor model with a fixed pipeline but configurable data structures and
execute behaviour. It is intended to be used to model processors with strict
in-order execution behaviour and allows visualisation of an instruction's
position in the pipeline through the MinorTrace/minorview.py format/tool. The
intention is to provide a framework for micro-architecturally correlating the
model with a particular, chosen processor with similar capabilities.

## Design Philosophy

### Multithreading

The model isn't currently capable of multithreading but there are THREAD
comments in key places where stage data needs to be arrayed to support
multithreading.

### Data structures

Decorating data structures with large amounts of life-cycle information is
avoided. Only instructions
([MinorDynInst](
https://gem5.github.io/gem5-doxygen/classMinor_1_1MinorDynInst.html)) contain a
significant proportion of their data content whose values are not set at
construction.

All internal structures have fixed sizes on construction. Data held in queues
and FIFOs ([MinorBuffer](
https://gem5.github.io/gem5-doxygen/classMinor_1_1MinorBuffer.html),
[FUPipeline](
https://gem5.github.io/gem5-doxygen/classMinor_1_1FUPipeline.html)) should have
a [BubbleIF](https://gem5.github.io/gem5-doxygen/classMinor_1_1BubbleIF.html)
interface to allow a distinct 'bubble'/no data value option for each type.

Inter-stage 'struct' data is packaged in structures which are passed by value.
Only [MinorDynInst](
https://gem5.github.io/gem5-doxygen/classMinor_1_1MinorDynInst.html), the line
data in [ForwardLineData](
https://gem5.github.io/gem5-doxygen/classMinorCPU.html#a36a7ec6a8c5a6d27fd013d8b0238029d)
and the memory-interfacing objects [Fetch1::FetchRequest](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch1_1_1FetchRequest.html)
and [LSQ::LSQRequest](
https://gem5.github.io/gem5-doxygen/classMinor_1_1LSQ_1_1LSQRequest.html) are
`::new` allocated while running the model.

## Model structure

Objects of class [MinorCPU](
https://gem5.github.io/gem5-doxygen/classMinorCPU.html) are provided by the
model to gem5. [MinorCPU](
https://gem5.github.io/gem5-doxygen/classMinorCPU.html) implements the
interfaces of (cpu.hh) and can provide data and instruction interfaces for
connection to a cache system. The model is configured in a similar way to other
gem5 models through Python. That configuration is passed on to
[MinorCPU::pipeline](
https://gem5.github.io/gem5-doxygen/classMinorCPU.html#a36a7ec6a8c5a6d27fd013d8b0238029d)
(of class [Pipeline](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Pipeline.html)) which
actually implements the processor pipeline.

The hierarchy of major unit ownership from [MinorCPU](
https://gem5.github.io/gem5-doxygen/classMinorCPU.html) down looks like this:

```
MinorCPU
--- Pipeline - container for the pipeline, owns the cyclic 'tick' event mechanism and the idling (cycle skipping) mechanism.
--- --- Fetch1 - instruction fetch unit responsible for fetching cache lines (or parts of lines from the I-cache interface).
--- --- --- Fetch1::IcachePort - interface to the I-cache from Fetch1.
--- --- Fetch2 - line to instruction decomposition.
--- --- Decode - instruction to micro-op decomposition.
--- --- Execute - instruction execution and data memory interface.
--- --- --- LSQ - load store queue for memory ref. instructions.
--- --- --- LSQ::DcachePort - interface to the D-ache from Execute.
```

## Key data structures

### Instruction and line identity: Instld (`dyn_inst.hh`)

```
- T/S.P/L - for fetched cache lines
- T/S.P/L/F - for instructions before Decode
- T/S.P/L/F.E - for instructions from Decode onwards
```

for example:

```
- 0/10.12/5/6.7
```

[InstId](https://gem5.github.io/gem5-doxygen/classMinor_1_1InstId.html) fields
are:

|Field|Symbol|Generated by|Checked by|Function|
|InstId::threadId|T|[Fetch1](https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch1.html) | Everywhere the thread number is needed| Thread number (currently always 0).
|InstId::streamSeqNum|S|[Execute](https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) | Fetch1, Fetch2, Execute (to discard lines/insts) | Stream sequence number as chosen by Execute. Stream sequence numbers change after changes of PC (branches, exceptions) in Execue and are used to separate pre and post brnach instrucion streams.|
|InstId::predictionSeqNum|[Fetch2](https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch2.html)| Fetch2 (while discarding lines after prediction)| Prediction sequence numbers represent branch prediction decisions. This is used by Fetch2 to mark lines/instructions/ according to the last followed branch prediction made by Fetch2. Fetch2 can signal to Fetch1 that it should change its fetch address and mark lines with a new prediction sequence number (which it will only do if the stream sequence number Fetch1 expects matches that of the request).
|InstId::lineSeqNum|[Fetch1](https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch1.html)| (just for debugging) | Line fetch sequence number of this cache line or the line this instruction was extracted from.|
|InstId::fetchSeqNum|[Fetch2](https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch2.html) | Fetch2 (as the inst. sequence number for branches) | Instruction fetch order assigned by Fetch2 when lines are decomposed into instructions.
|InstId::execSeqNum|[Decode](https://gem5.github.io/gem5-doxygen/classMinor_1_1Decode.html)


### Instructi ns: MinorDynInst (`dyn_inst.hh`)

### ForwardLineData (`pipe_data.hh`)

### ForwardInstData (`pipe_data.hh`)

### Fetch1::FetchRequest (`fetch1.hh`)

### LSQ::LSQRequest (`execute.hh`)

## The pipeline

### Event handling: MinorActivityRecorder (`activity.hh`, `pipeline.hh`)

### Each pipeline stage

### Fetch1 stage

### Fetch2 stage

#### Branch prediction

### Decode Stage

### Execute Stage

#### Functional units

#### Functional unit FIFOs

#### Issue

#### Commit

#### Advance

#### Scoreboard

#### Execute::inFlightInsts

#### LSQ

#### Draining

## Debug options

The model provides a number of debug flags which can be passed to gem5 with the
`–debug-flags` option.

The available flags are:

|Debug flag      | Unit which will generate debugging output |
|:---------------|:------------------------------------------|
|Activity        | [Debug](https://gem5.github.io/gem5-doxygen/namespaceDebug.html) ActivityMonitor actions |
|Branch          | [Fetch2](https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch2.html) and [Execute](https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) branch prediction decisions |
|[MinorCPU](https://gem5.github.io/gem5-doxygen/classMinorCPU.html)      | CPU global actions such as wakeup/thread suspension |
|[Decode](https://gem5.github.io/gem5-doxygen/classMinor_1_1Decode.html) | [Decode](https://gem5.github.io/gem5-doxygen/classMinor_1_1Decode.html) |
|MinorExec       | [Execute](https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) behaviour |
|Fetch           |[Fetch1](https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch1.html) and [Fetch2](https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch2.html) |
|MinorInterrupt  | [Execute](https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) interrupt handling  |
|MinorMem        | [Execute](https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) memory interactions |
|MinorScoreboard | [Execute](https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) scoreboard activity |
|MinorTrace      | Generate MinorTrace cyclic state trace output (see below) |
|MinorTiming     | MinorTiming instruction timing modification operations    |

The group flag [Minor](https://gem5.github.io/gem5-doxygen/namespaceMinor.html)
enables all the flags beginning with [Minor](
https://gem5.github.io/gem5-doxygen/namespaceMinor.html).

## MinorTrace and minorview.py

The debug flag MinorTrace causes cycle-by-cycle state data to be printed which
can then be processed and viewed by the minorview.py tool. This output is very
verbose and so it is recommended it only be used for small examples.

### MinorTrace format

There are three types of line outputted by MinorTrace:

#### MinorTrace - Ticked unit cycle state

For example:

```
 110000: system.cpu.dcachePort: MinorTrace: state=MemoryRunning in_tlb_mem=0/0
```

For each time step, the MinorTrace flag will cause one MinorTrace line to be
printed for every named element in the model.

#### MinorInst - summaries of instructions issued by Decode

[Decode](https://gem5.github.io/gem5-doxygen/classMinor_1_1Decode.html)

For example:

```
 140000: system.cpu.execute: MinorInst: id=0/1.1/1/1.1 addr=0x5c \
                             inst="  mov r0, #0" class=IntAlu
```

MinorInst lines are currently only generated for instructions which are committed.

#### MinorLine - summaries of line fetches issued by Fetch1

[Fetch1](https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch1.html)

For example:

```
  92000: system.cpu.icachePort: MinorLine: id=0/1.1/1 size=36 \
                                vaddr=0x5c paddr=0x5c
```

### minorview.py

Minorview (util/minorview.py) can be used to visualise the data created by
MinorTrace.

```
usage: minorview.py [-h] [--picture picture-file] [--prefix name]
                   [--start-time time] [--end-time time] [--mini-views]
                   event-file

Minor visualiser

positional arguments:
  event-file

optional arguments:
  -h, --help            show this help message and exit
  --picture picture-file
                        markup file containing blob information (default:
                        <minorview-path>/minor.pic)
  --prefix name         name prefix in trace for CPU to be visualised
                        (default: system.cpu)
  --start-time time     time of first event to load from file
  --end-time time       time of last event to load from file
  --mini-views          show tiny views of the next 10 time steps
```

Raw debugging output can be passed to minorview.py as the event-file. It will
pick out the MinorTrace lines and use other lines where units in the simulation
are named (such as system.cpu.dcachePort in the above example) will appear as
'comments' when units are clicked on the visualiser.

Clicking on a unit which contains instructions or lines will bring up a speech
bubble giving extra information derived from the MinorInst/MinorLine lines.

`–start-time` and `–end-time` allow only sections of debug files to be loaded.

`–prefix` allows the name prefix of the CPU to be inspected to be supplied.
This defaults to `system.cpu`.

In the visualiser, The buttons Start, End, Back, Forward, Play and Stop can be
used to control the displayed simulation time.

The diagonally striped coloured blocks are showing the [InstId](
https://gem5.github.io/gem5-doxygen/classMinor_1_1InstId.html) of the
instruction or line they represent. Note that lines in [Fetch1](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch1.html) and f1ToF2.F
only show the id fields of a line and that instructions in [Fetch2](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch2.html), f2ToD, and
decode.inputBuffer do not yet have execute sequence numbers. The T/S.P/L/F.E
buttons can be used to toggle parts of [InstId](
https://gem5.github.io/gem5-doxygen/classMinor_1_1InstId.html) on and off to
make it easier to understand the display. Useful combinations are:

|Combination|Reason                                                                                                                      |
|:----------|:---------------------------------------------------------------------------------------------------------------------------|
|E          |just show the final execute sequence number                                                                                 |
|F/E        |show the instruction-related numbers                                                                                        |
|S/P        |show just the stream-related numbers (watch the stream sequence change with branches and not change with predicted branches)|
|S/E        |show instructions and their stream                                                                                          |

The key to the right shows all the displayable colours (some of the colour
choices are quite bad!):

|Symbol |Meaning                                                      |
|:------|:------------------------------------------------------------|
|U      |Uknown data                                                  |
|B      |Blocked stage                                                |
|-      |Bubble                                                       |
|E      |Empty queue slot                                             |
|R      |Reserved queue slot                                          |
|F      |Fault                                                        |
|r      |Read (used as the leftmost stripe on data in the dcachePort) |
|w      |Write " "                                                    |
|0 to 9 |last decimal digit of the corresponding data                 |

```
    ,---------------.         .--------------.  *U
    | |=|->|=|->|=| |         ||=|||->||->|| |  *-  <- Fetch queues/LSQ
    `---------------'         `--------------'  *R
    === ======                                  *w  <- Activity/Stage activity
                              ,--------------.  *1
    ,--.      ,.      ,.      | ============ |  *3  <- Scoreboard
    |  |-\[]-\||-\[]-\||-\[]-\| ============ |  *5  <- Execute::inFlightInsts
    |  | :[] :||-/[]-/||-/[]-/| -. --------  |  *7
    |  |-/[]-/||  ^   ||      |  | --------- |  *9
    |  |      ||  |   ||      |  | ------    |
[]->|  |    ->||  |   ||      |  | ----      |
    |  |<-[]<-||<-+-<-||<-[]<-|  | ------    |->[] <- Execute to Fetch1,
    '--`      `'  ^   `'      | -' ------    |        Fetch2 branch data
             ---. |  ---.     `--------------'
             ---' |  ---'       ^       ^
                  |   ^         |       `------------ Execute
  MinorBuffer ----' input       `-------------------- Execute input buffer
                    buffer
```

Stages show the colours of the instructions currently being
generated/processed.

Forward FIFOs between stages show the data being pushed into them at the
current tick (to the left), the data in transit, and the data available at
their outputs (to the right).

The backwards FIFO between [Fetch2](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch2.html) and [Fetch1](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch1.html) shows branch
prediction data.

In general, all displayed data is correct at the end of a cycle's activity at
the time indicated but before the inter-stage FIFOs are ticked. Each FIFO has,
therefore an extra slot to show the asserted new input data, and all the data
currently within the FIFO.

Input buffers for each stage are shown below the corresponding stage and show
the contents of those buffers as horizontal strips. Strips marked as reserved
(cyan by default) are reserved to be filled by the previous stage. An input
buffer with all reserved or occupied slots will, therefore, block the previous
stage from generating output.

Fetch queues and [LSQ](
https://gem5.github.io/gem5-doxygen/classMinor_1_1LSQ.html) show the
lines/instructions in the queues of each interface and show the number of
lines/instructions in TLB and memory in the two striped colours of the top of
their frames.

Inside [Execute](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html), the horizontal
bars represent the individual FU pipelines. The vertical bar to the left is the
input buffer and the bar to the right, the instructions committed this cycle.
The background of [Execute](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) shows
instructions which are being committed this cycle in their original FU pipeline
positions.

The strip at the top of the [Execute](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) block shows the
current streamSeqNum that [Execute](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) is committing.
A similar stripe at the top of [Fetch1](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch1.html) shows that
stage's expected streamSeqNum and the stripe at the top of [Fetch2](
https://gem5.github.io/gem5-doxygen/classMinor_1_1Fetch2.html) shows its
issuing predictionSeqNum.

The scoreboard shows the number of instructions in flight which will commit a
result to the register in the position shown. The scoreboard contains slots for
each integer and floating point register.

The Execute::inFlightInsts queue shows all the instructions in flight in
[Execute](https://gem5.github.io/gem5-doxygen/classMinor_1_1Execute.html) with
the oldest instruction (the next instruction to be committed) to the right.

`Stage activity` shows the signalled activity (as E/1) for each stage (with CPU
miscellaneous activity to the left)

`Activity` show a count of stage and pipe activity.

### minor.pic format

The minor.pic file (src/minor/minor.pic) describes the layout of the models
blocks on the visualiser. Its format is described in the supplied minor.pic
file.

